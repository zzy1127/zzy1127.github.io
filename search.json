[{"title":"Java从入门到入土","url":"/2022/05/13/Java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","content":"<h2 id=\"基本特征\"><a href=\"#基本特征\" class=\"headerlink\" title=\"基本特征\"></a>基本特征</h2><ul>\n<li><p>Java核心机制：JVM虚拟机、代码安全性检测、垃圾回收</p>\n</li>\n<li><p>JDK&#x3D;JRE(JVM+API)+Tools</p>\n</li>\n<li><p>面向对象:继承、封装、多态</p>\n</li>\n<li><p>程序分类：Applet(嵌入网页)、Application</p>\n</li>\n<li><p>Tools: javac编译 java运行 jar打包 javadoc生成文档 javap反汇编</p>\n</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h3><p>1.使用Scanner类输入</p>\n<pre><code>先创建Scanner类对象\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scan</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str_1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str_2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num_1</span> <span class=\"operator\">=</span> scan.nextInt();<span class=\"comment\">//输入整数</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">num_2</span> <span class=\"operator\">=</span> scan.nextFloat();<span class=\"comment\">//输入浮点数</span></span><br><span class=\"line\">        str_1 = scan.nextLine();<span class=\"comment\">//输入字符串，可包含空格</span></span><br><span class=\"line\">        str_2 = scan.next();<span class=\"comment\">//输入字符串，不包含空格</span></span><br><span class=\"line\">        scan.close();<span class=\"comment\">//关闭输入流 一旦关闭则无法再读入</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>2.使用BufferedReader类输入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> num_1;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str_1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>();</span><br><span class=\"line\">        <span class=\"type\">BufferedReader</span> <span class=\"variable\">bf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in));</span><br><span class=\"line\">        <span class=\"comment\">//可能会有异常 要用try-catch</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            str_1 = bf.readLine();<span class=\"comment\">//读取一行字符串</span></span><br><span class=\"line\">            num_1 = bf.read();<span class=\"comment\">//读取单个字符并返回随对应的ASCII码</span></span><br><span class=\"line\">            bf.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>3.输出 使用System.out</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;hello world&quot;</span>);<span class=\"comment\">//换行输出</span></span><br><span class=\"line\">    System.out.print(<span class=\"string\">&quot;hello world&quot;</span>);<span class=\"comment\">//不换行输出</span></span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;%.2f&quot;</span>, <span class=\"number\">3.14</span>);<span class=\"comment\">//格式化输出</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据、运算、流程控制\"><a href=\"#数据、运算、流程控制\" class=\"headerlink\" title=\"数据、运算、流程控制\"></a>数据、运算、流程控制</h3><ul>\n<li><p>数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> [] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[size];<span class=\"comment\">//一维</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> [][] a = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][];<span class=\"comment\">//二维</span></span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[size];</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//类的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">classname [] a = <span class=\"keyword\">new</span> <span class=\"title class_\">classname</span>[size];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>break和continue</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">label: <span class=\"keyword\">while</span>()&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>/<span class=\"keyword\">continue</span> label;<span class=\"comment\">//可以加参数跳转到指定标签</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&gt;&gt;</code>带符号右移位  <code>&gt;&gt;&gt;</code>无符号右移位</p>\n</li>\n<li><p><code>&amp; ｜</code>可以表示逻辑运算 <code>&amp;&amp; ||</code>表示短路逻辑运算（第一个成立则不判断第二个）</p>\n</li>\n<li><p>JAVA中字符采用Unicode编码，占两个字节</p>\n</li>\n</ul>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><ul>\n<li>封装、继承、多态</li>\n</ul>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">public</span>][<span class=\"keyword\">abstract</span>|<span class=\"keyword\">final</span>] <span class=\"keyword\">class</span> <span class=\"title class_\">className</span> [<span class=\"keyword\">extends</span> <span class=\"title class_\">superClassName</span>] [<span class=\"keyword\">implements</span> <span class=\"title class_\">InterfaceNameList</span>]&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">public</span>|<span class=\"keyword\">protected</span>|<span class=\"keyword\">private</span>] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>] [<span class=\"keyword\">transient</span>] [<span class=\"keyword\">volatile</span>] type variableName;<span class=\"comment\">//字段定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">    [<span class=\"keyword\">public</span>|<span class=\"keyword\">protected</span>|<span class=\"keyword\">private</span>] [<span class=\"keyword\">static</span>] [<span class=\"keyword\">final</span>|<span class=\"keyword\">abstract</span>] [<span class=\"keyword\">native</span>] [<span class=\"keyword\">synchronized</span>] </span><br><span class=\"line\">    returnType <span class=\"title function_\">methodName</span><span class=\"params\">([paramList])</span><span class=\"comment\">//方法定义</span></span><br><span class=\"line\">    [<span class=\"keyword\">throws</span> exceptionList]&#123;</span><br><span class=\"line\">        statements</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问控制符</li>\n</ul>\n<p>类定义不加<code>public</code>则只能被同包中的访问</p>\n<p>成员变量</p>\n<p><img src=\"https://cdn.luogu.com.cn/upload/image_hosting/byw8n3g0.png\"></p>\n<ul>\n<li>其他修饰符</li>\n</ul>\n<p><code>static</code>表示类本身具有的字段&#x2F;方法，不局限于某个实例，使用时为<code>类名.方法名()</code></p>\n<p><code>static</code>方法中不能使用<code>this</code>、<code>super</code>,可以被子类重写</p>\n<p><code>final</code>类不可以被继承 字段不可以被修改 方法不可以被重写</p>\n<p><code>static final=const</code></p>\n<p><code>abstract</code>抽象类不能实例化，只能被<code>extends </code>方法只能定义（用;不用{}）然后被子类重写</p>\n<ul>\n<li>继承</li>\n</ul>\n<p>所有类的父类均为Object类</p>\n<p>只能<code>extends</code>一个父类，可用<code>super</code>代指</p>\n<p><code>this super</code>作构造函数时要放在第一行</p>\n<p>子类可以@Override 重写父类方法</p>\n<ul>\n<li>实现接口</li>\n</ul>\n<p><code>implements</code> 可以实现多个接口，每个接口不用实现全部方法</p>\n<h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">public</span>] <span class=\"keyword\">interface</span> <span class=\"title class_\">InterfaceName</span> [<span class=\"keyword\">extends</span> <span class=\"title class_\">superInterfaceList</span>]&#123;</span><br><span class=\"line\">    <span class=\"type\">type</span> <span class=\"variable\">constantName</span> <span class=\"operator\">=</span> Value;<span class=\"comment\">//常量声明 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    returnType <span class=\"title function_\">methodName</span><span class=\"params\">([paramList])</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><p>接口支持多继承，可以有多个接口为父类</p>\n</li>\n<li><p>接口中的字段为常量，可以被实现它的多个类使用，性质为<code>public static final</code></p>\n</li>\n<li><p>接口中的方法均为<code>public abstract</code></p>\n</li>\n<li><p>接口与抽象类的区别</p>\n</li>\n</ul>\n<p>1.抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n　　</p>\n<p>2.设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。\n　　</p>\n<p>3.抽象类是一个类，而接口不是类。</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><ul>\n<li>基本型变量和引用型变量</li>\n</ul>\n<p>基本型<strong>存储在栈中</strong>，如<code>int x = 5;</code>值直接存在变量中 </p>\n<p>引用型<strong>存储在堆中</strong>，对象实体由<code>new</code>创建，变量赋值时传递的是引用关系，即不同变量都可修改一个实体</p>\n<p>所有class都是Object类的子类，故class都是引用型</p>\n<p>基本类型的包装类可以将基本型变为引用型，分别为：<br><code>Integer Boolean Byte Short Character Long Float Double</code></p>\n<p>如<code>Integer I = new Integer(10);</code></p>\n<p>基本型和引用型可以转换，<strong>装箱</strong>就是把基本数据类型存储在堆中，把他变成引用类型；反过来<strong>拆箱</strong>，就是把引用类型中的数据放到栈中，要把它变成基本数据类型。</p>\n<p>如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">I</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;<span class=\"comment\">//装箱</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> I;<span class=\"comment\">//拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>变量的判等 <code>==</code></li>\n</ul>\n<p>基本型变量判断值是否相等</p>\n<p>引用型判断引用的是不是同一个对象实体</p>\n<p>装箱对象：</p>\n<p>实际上调用了<code>Integer I = Integer.valueOf(10)</code>此函数在值为-128到127之间有缓存，可以根据值判等。不在此范围内的即使值相等了但由于不是同一引用对象也判为不相等。</p>\n<p><code>string</code>：</p>\n<p>为引用类型。故要用<code>str1.equals(str2)</code>判断值是否相等。若为字符串常量 如<code>&quot;Hello&quot;</code> 因为常量会被内部化<code>intern</code>，在栈中常量池产生实体对象，所以可以用<code>==</code>判等</p>\n<ul>\n<li>字段变量和局部变量</li>\n</ul>\n<p>字段变量属于类，在堆中，可被访问控制符修饰。局部变量在栈中，只能被<code>final</code>修饰</p>\n<h2 id=\"进阶操作\"><a href=\"#进阶操作\" class=\"headerlink\" title=\"进阶操作\"></a>进阶操作</h2><h3 id=\"多态与虚方法调用\"><a href=\"#多态与虚方法调用\" class=\"headerlink\" title=\"多态与虚方法调用\"></a>多态与虚方法调用</h3><ul>\n<li><p>多态包括编译时多态：重载同名的不同方法（@Overload）和运行时多态：重写（@Override）动态绑定和虚方法调用</p>\n</li>\n<li><p>上溯造型（upcasting）</p>\n</li>\n</ul>\n<p>父类可以引用到子类上,如<code>Person p = new Student()</code>，同时父类的形参也可以传入子类的实参</p>\n<ul>\n<li>虚方法调用</li>\n</ul>\n<p>所有的方法，除static（属于类）、final（不会被子类重写）、private（子类看不见）都是虚方法。</p>\n<p>虚方法在调用时，根据调用该方法的<strong>实例的类型</strong>进行动态绑定，决定使用哪个方法。</p>\n<p>例如：当父类引用到子类上时，p的引用类型实际上为子类Student，声明类型为Person。这时如果子类（p的类型）重写了父类的某个虚方法，在调用这个方法时会动态绑定到子类的这个方法上。但是p的其他方法和字段会根据声明的类型确定，即Person类。</p>\n<p>static方法因为不是虚方法，因此他的调用取决于声明类型而不是引用类型</p>\n<h3 id=\"对象构造\"><a href=\"#对象构造\" class=\"headerlink\" title=\"对象构造\"></a>对象构造</h3><ul>\n<li>构造方法</li>\n</ul>\n<p>所以类都有构造方法。不写会自动加默认构造方法。抽象类也有构造方法，但需要被子类重写。</p>\n<p>构造方法可以有多个（重载），可以用<code>this</code>调用本类的其他构造方法。子类可以用<code>super</code>调用父类的构造方法。</p>\n<p><strong>调用时super和this必须放在第一行且一个构造函数只能调用一个构造函数</strong></p>\n<p>子类的构造方法会自动在第一行调用<code>super</code>即父类的默认构造方法。因为只有父类构造好才能构造子类。注意如果父类的构造方法需要参数，则子类必须手动写<code>super</code>，因为调用默认构造方法时没有参数会出错。</p>\n<p>一种特殊写法（创建实例时）:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()&#123;&#123;age = <span class=\"number\">18</span>; name = <span class=\"string\">&quot;Bob&quot;</span>;&#125;&#125;;<span class=\"comment\">//双括号</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>实例初始化与静态初始化</li>\n</ul>\n<p>实例初始化：在类中直接写<code>&#123;expr...&#125;</code>先于构造方法中的语句执行。</p>\n<p>静态初始化：类中写<code>static &#123;expr...&#125;</code>在第一次用到这个类时执行，先于实例初始化。</p>\n<ul>\n<li>构造顺序</li>\n</ul>\n<p>1.先执行<code>this()</code>或<code>super()</code></p>\n<p>2.执行字段初始化（字段定义时赋的值）和实例、静态初始化</p>\n<p>3.执行构造函数其他语句</p>\n<p>在构造方法中尽量避免调用别的非构造方法</p>\n<h3 id=\"对象清除与垃圾回收\"><a href=\"#对象清除与垃圾回收\" class=\"headerlink\" title=\"对象清除与垃圾回收\"></a>对象清除与垃圾回收</h3><p>对象会自动被系统回收，无需删除。任何对象都有一个引用计时器，当为0时会自动被Java虚拟机垃圾回收线程回收。</p>\n<p><code>System.gc()</code>可以建议此时进行一次垃圾回收。</p>\n<p>Java中没有析构方法。但是可以写<code>protected void finalize()&#123;&#125;</code>方法，此方法会在对象被回收时自动调用。一般来说，子类的<code>finalize()</code>方法中应当调用父类的<code>super.finalize()</code>。</p>\n<p>可以使用以下try-with-resources语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>(类名 实例名 = <span class=\"keyword\">new</span> 类名())&#123;</span><br><span class=\"line\">    expr...</span><br><span class=\"line\">&#125;<span class=\"comment\">//执行完之后此实例会被自动回收并调用close方法</span></span><br></pre></td></tr></table></figure>\n<p>要构造一个能被try-with-resources块正确处理的自定义资源，此类应该实现Closeable或AutoCloseable接口，并重写它的close方法:</p>\n<p>比如Scanner类</p>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>类中的class，定义时直接写，可以用访问修饰符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用时</span></span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">A.<span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> a.<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();<span class=\"comment\">//必须有A的实例才能生成B的实例</span></span><br></pre></td></tr></table></figure>\n\n<p>内部类可以直接访问外部类的成员，即使private也可以，若变量重名，应使用<code>A.this.x</code>才能表示外部类的变量，其他表示都是内部类的。</p>\n<ul>\n<li>static修饰的内部类</li>\n</ul>\n<p>静态类与实例无关，因此声明时为<code>A.B b = new A.B()</code>，同时，静态类不能访问外部类中的非static内容。</p>\n<ul>\n<li>局部类</li>\n</ul>\n<p>在方法中定义局部类。同局部变量一样，存放在栈中，只能使用final或abstrct作为修饰符。</p>\n<p>可以访问外部类的成员但是不能访问该方法中的其他非final局部变量。</p>\n<h3 id=\"匿名类\"><a href=\"#匿名类\" class=\"headerlink\" title=\"匿名类\"></a>匿名类</h3><p>不取名字，使用父类名字（Object）或者接口名字，在定义的同时生成一个对象，一次性。</p>\n<p><code>new 父类名或接口名()&#123;...(可以Override一些方法)&#125;</code></p>\n<p>如果需要参数则括号中会调用父类的构造函数。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重写book类的比较器对books数组排序</span></span><br><span class=\"line\"><span class=\"comment\">//使用Arrays类的静态方法sort</span></span><br><span class=\"line\"><span class=\"comment\">//第二个参数为一个匿名类，它实现了Comparator接口中的compare方法</span></span><br><span class=\"line\">Arrays.&lt;book&gt;sort(books,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;book&gt;()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(book a,book b)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.getprice()-b.getprice();<span class=\"comment\">//价格从大到小排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lamda表达式\"><a href=\"#lamda表达式\" class=\"headerlink\" title=\"lamda表达式\"></a>lamda表达式</h3><p>形式：<code>参数 -&gt; 结果</code></p>\n<p>参数可以是 参数 () (多个参数) 结果可以加大括号写多个语句。</p>\n<p>相当于函数的指针，实际上是实现接口的匿名类的实例。</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Fun</span>&#123;<span class=\"comment\">//一个接口</span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">Integral</span><span class=\"params\">(Fun f, <span class=\"type\">double</span> a, <span class=\"type\">double</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//对f.fun函数的积分</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用时可以写为</span></span><br><span class=\"line\"><span class=\"comment\">//使用匿名类实现接口</span></span><br><span class=\"line\">Integral(<span class=\"keyword\">new</span> <span class=\"title class_\">Fun</span>()&#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"title function_\">fun</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,a, b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lambda表达式实现接口</span></span><br><span class=\"line\">Integral(x -&gt; x+<span class=\"number\">1</span>, a, b);</span><br></pre></td></tr></table></figure>\n<p>实现哪个接口由形参决定。由于没有决定实现接口的哪个方法，故该接口只能有一个方法。这样的接口用注记表示为<code>@FunctionalInterface</code>函数式接口</p>\n","categories":["语言"],"tags":["Java"]}]